// src/components/SvgGlyphEditor.tsx
'use client';

import React, {
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';

import useGlyphs from '@hooks/useGlyphs';
import {
  GLYPH_SKELETONS,
  GLYPH_METRICS,
  DEFAULT_GLYPH_METRIC,
  type GlyphSkeletonAnchor,
  type GlyphSkeletonStrokeDef,
} from '@mytypes/glyph';

type Point = {
  x: number;
  y: number;
};

type Stroke = {
  id: string;
  p0: Point;
  p1: Point;
  ctrl?: Point; // if present → quadratic Bezier, otherwise straight line
  width: number;
};

type StrokeGroup = {
  id: string;
  strokeIds: string[];
};

type DrawMode = 'stroke' | 'circle' | 'letter' | 'select';

type SvgGlyphEditorProps = {
  sid: string;
  letter: string;
  variantIndex?: number;
};

const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 600;

// Exported SVG: only the real strokes (lines or curves), no guides/preview/letter
function serializeGlyphToSvg(strokes: Stroke[], letter: string): string {
  void letter; // intentionally unused in output

  const width = CANVAS_WIDTH;
  const height = CANVAS_HEIGHT;

  const elements = strokes
    .map(s => {
      const { p0, p1, ctrl, width } = s;
      if (ctrl) {
        // Quadratic Bezier: M p0 Q ctrl p1
        return `<path d="M ${p0.x.toFixed(2)} ${p0.y.toFixed(
          2,
        )} Q ${ctrl.x.toFixed(2)} ${ctrl.y.toFixed(
          2,
        )} ${p1.x.toFixed(2)} ${p1.y.toFixed(
          2,
        )}" stroke-width="${width}" />`;
      }
      // Straight line
      return `<line x1="${p0.x.toFixed(2)}" y1="${p0.y.toFixed(
        2,
      )}" x2="${p1.x.toFixed(2)}" y2="${p1.y.toFixed(
        2,
      )}" stroke-width="${width}" />`;
    })
    .join('\n    ');

  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 ${width} ${height}"
>
  <g stroke="black" stroke-linecap="round" stroke-linejoin="round" fill="none">
    ${elements}
  </g>
</svg>`;

  return svg;
}

// midpoint helper
function midpoint(a: Point, b: Point): Point {
  return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
}

// distance helper
function distance(a: Point, b: Point): number {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

// Parse our own serialized SVG back into strokes.
// Assumes the same simple line / quadratic path format as serializeGlyphToSvg().
function parseSvgToStrokes(svgContent: string): Stroke[] {
  const strokes: Stroke[] = [];
  if (!svgContent) return strokes;

  const lineRegex =
    /<line[^>]*x1="([^"]+)"[^>]*y1="([^"]+)"[^>]*x2="([^"]+)"[^>]*y2="([^"]+)"[^>]*stroke-width="([^"]+)"[^>]*\/?>/g;
  const pathRegex =
    /<path[^>]*d="M\s*([-0-9.]+)\s+([-0-9.]+)\s+Q\s+([-0-9.]+)\s+([-0-9.]+)\s+([-0-9.]+)\s+([-0-9.]+)"[^>]*stroke-width="([^"]+)"[^>]*\/?>/g;

  let match: RegExpExecArray | null;

  while ((match = lineRegex.exec(svgContent)) !== null) {
    const [, x1, y1, x2, y2, width] = match;
    const w = parseFloat(width);
    strokes.push({
      id: `stroke-line-${strokes.length}-${Date.now()}`,
      p0: { x: parseFloat(x1), y: parseFloat(y1) },
      p1: { x: parseFloat(x2), y: parseFloat(y2) },
      width: Number.isFinite(w) ? w : 8,
    });
  }

  while ((match = pathRegex.exec(svgContent)) !== null) {
    const [, x0, y0, cx, cy, x1, y1, width] = match;
    const w = parseFloat(width);
    strokes.push({
      id: `stroke-path-${strokes.length}-${Date.now()}`,
      p0: { x: parseFloat(x0), y: parseFloat(y0) },
      p1: { x: parseFloat(x1), y: parseFloat(y1) },
      ctrl: { x: parseFloat(cx), y: parseFloat(cy) },
      width: Number.isFinite(w) ? w : 8,
    });
  }

  return strokes;
}

// Helper to approximate a circle by multiple straight segments.
function createCircleStrokes(
  center: Point,
  edgePoint: Point,
  baseWidth: number,
): Stroke[] {
  const r = distance(center, edgePoint);
  if (!Number.isFinite(r) || r <= 0) return [];

  const segments = 24; // reasonable smoothness
  const strokes: Stroke[] = [];
  const now = Date.now();

  for (let i = 0; i < segments; i++) {
    const t0 = (i / segments) * 2 * Math.PI;
    const t1 = ((i + 1) / segments) * 2 * Math.PI;
    const p0: Point = {
      x: center.x + r * Math.cos(t0),
      y: center.y + r * Math.sin(t0),
    };
    const p1: Point = {
      x: center.x + r * Math.cos(t1),
      y: center.y + r * Math.sin(t1),
    };
    strokes.push({
      id: `stroke-circle-${now}-${i}`,
      p0,
      p1,
      width: baseWidth,
    });
  }

  return strokes;
}
 

function mapSkeletonY(
  anchor: GlyphSkeletonAnchor,
  geom: {
    ascenderY: number;
    xHeightY: number;
    baselineY: number;
    descenderY: number;
  },
): number {
  const { ascenderY, xHeightY, baselineY, descenderY } = geom;
  switch (anchor) {
    case 'ascender':
      return ascenderY;
    case 'xheight':
      return xHeightY;
    case 'baseline':
      return baselineY;
    case 'descender':
      return descenderY;
  }
}

function createLetterSkeletonStrokes(
  glyphLetter: string,
  geom: {
    marginX: number;
    baselineY: number;
    xHeightY: number;
    ascenderY: number;
    descenderY: number;
    canvasWidth: number;
    glyphLeftX: number;
    glyphRightX: number;
  },
  baseWidth: number,
): Stroke[] {
  const ch = (glyphLetter || 'A').toUpperCase();
  const def = GLYPH_SKELETONS[ch];

  const {
    baselineY,
    xHeightY,
    ascenderY,
    descenderY,
    canvasWidth,
    glyphLeftX,
    glyphRightX,
  } = geom;

  if (def) {
    const usableWidth = glyphRightX - glyphLeftX;
    const now = Date.now();

    const strokes: Stroke[] = def.strokes.map(
      (s: GlyphSkeletonStrokeDef, idx: number) => {
        const fromX = glyphLeftX + s.from.x * usableWidth;
        const toX = glyphLeftX + s.to.x * usableWidth;

        const fromY = mapSkeletonY(s.from.y, {
          ascenderY,
          xHeightY,
          baselineY,
          descenderY,
        });
        const toY = mapSkeletonY(s.to.y, {
          ascenderY,
          xHeightY,
          baselineY,
          descenderY,
        });

        return {
          id: `stroke-letter-${ch}-${now}-${idx}`,
          p0: { x: fromX, y: fromY },
          p1: { x: toX, y: toY },
          width: baseWidth,
        };
      },
    );

    return strokes;
  }

  // Fallback: generic O-like circle skeleton for letters without config yet,
  // keep it inside the same fictive body horizontally.
  const center: Point = {
    x: (glyphLeftX + glyphRightX) / 2,
    y: (ascenderY + baselineY) / 2,
  };
  const radius = Math.min(
    (baselineY - ascenderY) / 2,
    (glyphRightX - glyphLeftX) / 2,
  );
  const edge: Point = {
    x: center.x + radius,
    y: center.y,
  };

  return createCircleStrokes(center, edge, baseWidth);
}

// Bounding box helper for a stroke (incl. ctrl if present)
function strokeBoundingBox(s: Stroke) {
  const xs = [s.p0.x, s.p1.x];
  const ys = [s.p0.y, s.p1.y];
  if (s.ctrl) {
    xs.push(s.ctrl.x);
    ys.push(s.ctrl.y);
  }
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  return { minX, maxX, minY, maxY };
}

// Center point of bounding box
function strokeCenter(s: Stroke): Point {
  const { minX, maxX, minY, maxY } = strokeBoundingBox(s);
  return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
}

// Check if a point is inside a rect
function pointInRect(
  p: Point,
  rect: { x1: number; y1: number; x2: number; y2: number },
): boolean {
  return p.x >= rect.x1 && p.x <= rect.x2 && p.y >= rect.y1 && p.y <= rect.y2;
}

const SvgGlyphEditor: React.FC<SvgGlyphEditorProps> = ({
  sid,
  letter,
  variantIndex,
}) => {
  const [strokes, setStrokes] = useState<Stroke[]>([]);
  const [history, setHistory] = useState<Stroke[][]>([]);
  const [redoStack, setRedoStack] = useState<Stroke[][]>([]);
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const [groups, setGroups] = useState<StrokeGroup[]>([]);

  const [pendingStart, setPendingStart] = useState<Point | null>(null);
  const [previewPoint, setPreviewPoint] = useState<Point | null>(null);
  const [draggingCtrlForId, setDraggingCtrlForId] = useState<string | null>(
    null,
  );

  const [drawMode, setDrawMode] = useState<DrawMode>('stroke');

  // Dragging whole strokes (multi-select)
  const [isDraggingSelection, setIsDraggingSelection] = useState(false);
  const dragStartRef = useRef<Point | null>(null);
  const dragInitialStrokesRef = useRef<Stroke[]>([]);

  // Marquee selection
  const [selectionRectStart, setSelectionRectStart] =
    useState<Point | null>(null);
  const [selectionRectEnd, setSelectionRectEnd] =
    useState<Point | null>(null);

  const svgRef = useRef<SVGSVGElement | null>(null);

  const svgCode = useMemo(
    () => serializeGlyphToSvg(strokes, letter),
    [strokes, letter],
  );

  // Hook for SVG glyphs
  const {
    glyphs,
    fetchGlyphs,
    uploadGlyphFromEditor,
    isUpdating: isUploadingGlyph,
  } = useGlyphs(sid, {
    manual: true,
    initialLetter: letter,
    formattype: 'svg',
  });

  // Expand a selection by group membership:
  // if any stroke of a group is selected, the whole group becomes selected.
  const expandWithGroups = (ids: string[]): string[] => {
    if (!ids.length || !groups.length) return ids;
    const idSet = new Set(ids);
    let changed = true;

    while (changed) {
      changed = false;
      for (const g of groups) {
        const inGroup = g.strokeIds.some(id => idSet.has(id));
        if (inGroup) {
          for (const id of g.strokeIds) {
            if (!idSet.has(id)) {
              idSet.add(id);
              changed = true;
            }
          }
        }
      }
    }

    return Array.from(idSet);
  };

  // Helper: push current strokes into history, clear redo, then compute new strokes
  const updateStrokes = (updater: (prev: Stroke[]) => Stroke[]) => {
    setStrokes(prev => {
      setHistory(h => [...h, prev]);
      setRedoStack([]); // new branch, discard redo history
      return updater(prev);
    });
  };

  const clearTransientState = () => {
    setPendingStart(null);
    setPreviewPoint(null);
    setDraggingCtrlForId(null);
    setIsDraggingSelection(false);
    dragStartRef.current = null;
    dragInitialStrokesRef.current = [];
    setSelectionRectStart(null);
    setSelectionRectEnd(null);
  };

  const resetEditorToEmpty = () => {
    setStrokes([]);
    setHistory([]);
    setRedoStack([]);
    setSelectedIds([]);
    setGroups([]);
    clearTransientState();
  };

  // ----- Canvas mouse handlers -----

  const handleCanvasMouseDown = (e: React.MouseEvent<SVGSVGElement>) => {
    if (drawMode !== 'select') return;
    const svg = svgRef.current;
    if (!svg) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const p: Point = { x, y };

    // Start marquee selection
    setSelectionRectStart(p);
    setSelectionRectEnd(p);
  };

  const handleCanvasClick = (e: React.MouseEvent<SVGSVGElement>) => {
    // In select mode, clicks are handled via drag/mouseup for rectangle; ignore simple click
    if (drawMode === 'select') return;
    if (draggingCtrlForId || isDraggingSelection) return; // ignore clicks while dragging
    const svg = svgRef.current;
    if (!svg) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const point: Point = { x, y };

    // Letter mode: insert skeleton in the canonical position, ignore click position
    if (drawMode === 'letter') {
      const trimmedLetter = letter.trim() || 'A';

      // Geometry based on current canvas + guidelines
      const marginX = CANVAS_WIDTH * 0.1;
      const marginBottom = CANVAS_HEIGHT * 0.1;
      const baselineY = CANVAS_HEIGHT - marginBottom;
      const xHeightY = baselineY - CANVAS_HEIGHT * 0.3;
      const ascenderY = baselineY - CANVAS_HEIGHT * 0.5;
      const descenderY = CANVAS_HEIGHT + CANVAS_HEIGHT * 0.05; // same as baseline + 0.15*H

      // Per-letter metric profile (fictive body)
      const metricKey = trimmedLetter || 'A';
      const metricProfile =
        GLYPH_METRICS[metricKey] ??
        GLYPH_METRICS[metricKey.toUpperCase()] ??
        DEFAULT_GLYPH_METRIC;

      const glyphLeftX =
        CANVAS_WIDTH * (metricProfile.leftBearingFactor ?? 0.15);
      const glyphRightX =
        glyphLeftX +
        CANVAS_WIDTH * (metricProfile.widthFactor ?? 0.7);

      const skeleton = createLetterSkeletonStrokes(
        trimmedLetter,
        {
          marginX,
          baselineY,
          xHeightY,
          ascenderY,
          descenderY,
          canvasWidth: CANVAS_WIDTH,
          glyphLeftX,
          glyphRightX,
        },
        8,
      );

      if (skeleton.length) {
        updateStrokes(prev => [...prev, ...skeleton]);
      }

      // No two-click behaviour in letter mode
      setPendingStart(null);
      setPreviewPoint(null);
      return;
    }

    // Stroke / circle mode: two-click behaviour
    if (!pendingStart) {
      // First click: set start point, keep selection as-is
      setPendingStart(point);
      setPreviewPoint(null);
    } else {
      // Second click: create stroke or circle
      const start = pendingStart;

      if (drawMode === 'stroke') {
        updateStrokes(prev => [
          ...prev,
          {
            id: `stroke-${Date.now()}-${Math.random()
              .toString(36)
              .slice(2, 7)}`,
            p0: start,
            p1: point,
            width: 8,
          },
        ]);
      } else if (drawMode === 'circle') {
        const circleStrokes = createCircleStrokes(start, point, 8);
        if (circleStrokes.length) {
          updateStrokes(prev => [...prev, ...circleStrokes]);
        }
      }

      setPendingStart(null);
      setPreviewPoint(null);
    }
  };

  const handleCanvasMouseMove = (e: React.MouseEvent<SVGSVGElement>) => {
    const svg = svgRef.current;
    if (!svg) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const point: Point = { x, y };

    if (drawMode === 'select' && selectionRectStart) {
      setSelectionRectEnd(point);
      return;
    }

    if (draggingCtrlForId) {
      // Dragging a control point: update ctrl of that stroke (with history)
      updateStrokes(prev =>
        prev.map(s =>
          s.id === draggingCtrlForId ? { ...s, ctrl: point } : s,
        ),
      );
      return;
    }

    if (isDraggingSelection && dragStartRef.current) {
      // Dragging selected strokes: no history on each move, only on mouse up
      const dx = point.x - dragStartRef.current.x;
      const dy = point.y - dragStartRef.current.y;

      const base = dragInitialStrokesRef.current;
      setStrokes(
        base.map(s => {
          if (!selectedIds.includes(s.id)) return s;
          const shifted: Stroke = {
            ...s,
            p0: { x: s.p0.x + dx, y: s.p0.y + dy },
            p1: { x: s.p1.x + dx, y: s.p1.y + dy },
          };
          if (s.ctrl) {
            shifted.ctrl = { x: s.ctrl.x + dx, y: s.ctrl.y + dy };
          }
          return shifted;
        }),
      );
      return;
    }

    if (pendingStart && (drawMode === 'stroke' || drawMode === 'circle')) {
      setPreviewPoint(point);
    }
  };

  const handleCanvasMouseUp = () => {
    if (draggingCtrlForId) {
      setDraggingCtrlForId(null);
    }

    if (drawMode === 'select' && selectionRectStart && selectionRectEnd) {
      const x1 = Math.min(selectionRectStart.x, selectionRectEnd.x);
      const x2 = Math.max(selectionRectStart.x, selectionRectEnd.x);
      const y1 = Math.min(selectionRectStart.y, selectionRectEnd.y);
      const y2 = Math.max(selectionRectStart.y, selectionRectEnd.y);

      const rect = { x1, x2, y1, y2 };

      const hitIds = strokes
        .filter(s => pointInRect(strokeCenter(s), rect))
        .map(s => s.id);

      if (hitIds.length) {
        setSelectedIds(prev => {
          const prevSet = new Set(prev);
          const nextSet = new Set(prevSet);

          for (const id of hitIds) {
            if (prevSet.has(id)) nextSet.delete(id);
            else nextSet.add(id);
          }

          const expanded = expandWithGroups(Array.from(nextSet));
          return expanded;
        });
      }

      setSelectionRectStart(null);
      setSelectionRectEnd(null);
    }

    if (isDraggingSelection) {
      // Finalize move as a single history step
      setHistory(h => [...h, dragInitialStrokesRef.current]);
      setRedoStack([]); // moving selection starts a new branch
      setIsDraggingSelection(false);
      dragStartRef.current = null;
      dragInitialStrokesRef.current = [];
    }
  };

  const handleStrokeMouseDown = (
    e: React.MouseEvent<SVGPathElement | SVGLineElement, MouseEvent>,
    strokeId: string,
  ) => {
    e.stopPropagation();
    const svg = svgRef.current;
    if (!svg) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const point: Point = { x, y };

    setPendingStart(null);
    setPreviewPoint(null);

    setSelectedIds(prev => {
      const multi =
        e.shiftKey || e.ctrlKey || (e.metaKey ?? false);

      let next: string[];
      if (multi) {
        if (prev.includes(strokeId)) {
          // toggle off + whole group off
          const toRemove = expandWithGroups([strokeId]);
          next = prev.filter(id => !toRemove.includes(id));
        } else {
          // add + whole group on
          next = expandWithGroups([...prev, strokeId]);
        }
      } else {
        if (prev.length === 1 && prev[0] === strokeId) {
          // Click on already-selected stroke without modifiers → deselect (group as well)
          const toRemove = expandWithGroups([strokeId]);
          next = prev.filter(id => !toRemove.includes(id));
        } else {
          // Select this stroke (and its group) exclusively
          next = expandWithGroups([strokeId]);
        }
      }

      if (next.includes(strokeId)) {
        dragStartRef.current = point;
        dragInitialStrokesRef.current = strokes;
        setIsDraggingSelection(true);
      } else {
        dragStartRef.current = null;
        dragInitialStrokesRef.current = [];
        setIsDraggingSelection(false);
      }

      return next;
    });
  };

  const handleStrokeClick = (
    e: React.MouseEvent<SVGPathElement | SVGLineElement, MouseEvent>,
    strokeId: string,
  ) => {
    // Click: ensure stroke has a ctrl so it can be bent. Selection is handled in mouseDown.
    e.stopPropagation();
    setPendingStart(null);
    setPreviewPoint(null);

    updateStrokes(prev =>
      prev.map(s => {
        if (s.id !== strokeId) return s;
        if (s.ctrl) return s;
        return { ...s, ctrl: midpoint(s.p0, s.p1) };
      }),
    );
  };

  const startDragControl = (
    e: React.MouseEvent<SVGCircleElement, MouseEvent>,
    strokeId: string,
  ) => {
    e.stopPropagation();
    e.preventDefault();
    setSelectedIds(expandWithGroups([strokeId]));
    setDraggingCtrlForId(strokeId);
  };

  const adjustWidth = (delta: number) => {
    if (!selectedIds.length) return;
    updateStrokes(prev =>
      prev.map(s =>
        selectedIds.includes(s.id)
          ? {
              ...s,
              width: Math.max(1, Math.min(50, s.width + delta)),
            }
          : s,
      ),
    );
  };

  const handleClearAll = () => {
    if (!strokes.length) return;
    updateStrokes(() => []);
    setSelectedIds([]);
    setGroups([]);
    clearTransientState();
  };

  const handleUndo = () => {
    setHistory(prevHistory => {
      if (!prevHistory.length) return prevHistory;

      const last = prevHistory[prevHistory.length - 1];

      setStrokes(current => {
        setRedoStack(r => [...r, current]);
        return last;
      });

      setSelectedIds([]);
      clearTransientState();

      return prevHistory.slice(0, -1);
    });
  };

  const handleRedo = () => {
    setRedoStack(prevRedo => {
      if (!prevRedo.length) return prevRedo;

      const last = prevRedo[prevRedo.length - 1];

      setStrokes(current => {
        setHistory(h => [...h, current]);
        return last;
      });

      setSelectedIds([]);
      clearTransientState();

      return prevRedo.slice(0, -1);
    });
  };

  const handleDeleteSelected = () => {
    if (!selectedIds.length) return;
    const idsToRemove = new Set(selectedIds);

    updateStrokes(prev => prev.filter(s => !idsToRemove.has(s.id)));

    // Drop deleted strokes from groups
    setGroups(prev =>
      prev
        .map(g => ({
          ...g,
          strokeIds: g.strokeIds.filter(id => !idsToRemove.has(id)),
        }))
        .filter(g => g.strokeIds.length > 0),
    );

    setSelectedIds([]);
    clearTransientState();
  };

  const handleGroupSelection = () => {
    const ids = Array.from(new Set(selectedIds));
    if (ids.length < 2) return;

    setGroups(prev => {
      // Remove these strokes from any existing groups
      const idsSet = new Set(ids);
      const cleaned = prev
        .map(g => ({
          ...g,
          strokeIds: g.strokeIds.filter(id => !idsSet.has(id)),
        }))
        .filter(g => g.strokeIds.length > 0);

      const newGroup: StrokeGroup = {
        id: `group-${Date.now()}-${Math.random()
          .toString(36)
          .slice(2, 7)}`,
        strokeIds: ids,
      };

      return [...cleaned, newGroup];
    });

    // Re-expand selection with new grouping
    setSelectedIds(expandWithGroups(selectedIds));
  };

  const handleUngroupSelection = () => {
    if (!selectedIds.length || !groups.length) return;
    const selectedSet = new Set(selectedIds);

    setGroups(prev =>
      prev.filter(g => !g.strokeIds.some(id => selectedSet.has(id))),
    );

    // Selection remains as-is, but no further implicit grouping.
  };

  const handleUploadToBackend = async () => {
    const trimmedLetter = letter.trim();
    if (!trimmedLetter) return;
    if (!strokes.length) return;
    if (!sid) return;

    try {
      const svgBlob = new Blob([svgCode], {
        type: 'image/svg+xml;charset=utf-8',
      });
      await uploadGlyphFromEditor(trimmedLetter, svgBlob);
    } catch (err) {
      console.error(
        '[SvgGlyphEditor] uploadGlyphFromEditor failed:',
        err,
      );
    }
  };

  // 1) Whenever sid/letter changes, fetch SVG glyph meta for that letter
  useEffect(() => {
    const trimmedLetter = letter.trim();
    if (!sid || !trimmedLetter) {
      resetEditorToEmpty();
      return;
    }

    fetchGlyphs({ letter: trimmedLetter }).catch(err => {
      console.error('[SvgGlyphEditor] fetchGlyphs failed:', err);
      resetEditorToEmpty();
    });
  }, [sid, letter, fetchGlyphs]);

  // 2) Whenever glyphs change, try to load the default SVG for this letter
  useEffect(() => {
    const trimmedLetter = letter.trim();
    if (!sid || !trimmedLetter) {
      resetEditorToEmpty();
      return;
    }

    const glyphsForLetter = glyphs.filter(g => g.letter === trimmedLetter);
    if (!glyphsForLetter.length) {
      resetEditorToEmpty();
      return;
    }

    const requested =
      typeof variantIndex === 'number'
        ? glyphsForLetter.find(g => g.variant_index === variantIndex)
        : undefined;

    const svgGlyph =
      requested ??
      glyphsForLetter.find(g => g.is_default) ??
      glyphsForLetter[0];

    if (!svgGlyph || !svgGlyph.image_path) {
      resetEditorToEmpty();
      return;
    }

    let url = svgGlyph.image_path;

    // Heuristic: if it's a relative media path, prefix /media/
    if (!/^https?:\/\//i.test(url)) {
      if (!url.startsWith('/')) {
        url = `/media/${url}`;
      }
    }

    let cancelled = false;

    (async () => {
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const svgText = await res.text();
        if (cancelled) return;

        if (!svgText.trim()) {
          resetEditorToEmpty();
          return;
        }

        const parsed = parseSvgToStrokes(svgText);
        setStrokes(parsed);
        setHistory([]);
        setRedoStack([]);
        setSelectedIds([]);
        setGroups([]);
        clearTransientState();
      } catch (err) {
        console.warn(
          '[SvgGlyphEditor] Failed to load existing SVG, starting empty:',
          err,
        );
        if (!cancelled) {
          resetEditorToEmpty();
        }
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [glyphs, sid, letter, variantIndex]);

  // Geometry for guidelines + preview letter
  const marginX = CANVAS_WIDTH * 0.1;
  const marginBottom = CANVAS_HEIGHT * 0.1;
  const baselineY = CANVAS_HEIGHT - marginBottom;
  const xHeightY = baselineY - CANVAS_HEIGHT * 0.3;
  const ascenderY = baselineY - CANVAS_HEIGHT * 0.5;
  const descenderY = baselineY + CANVAS_HEIGHT * 0.15;

  const previewLetter = letter.trim() || 'A';

  // Fictive body for the current preview letter
  const metricProfile =
    GLYPH_METRICS[previewLetter] ??
    GLYPH_METRICS[previewLetter.toUpperCase()] ??
    DEFAULT_GLYPH_METRIC;

  const glyphLeftX =
    CANVAS_WIDTH * (metricProfile.leftBearingFactor ?? 0.15);
  const glyphRightX =
    glyphLeftX +
    CANVAS_WIDTH * (metricProfile.widthFactor ?? 0.7);

  const hasSelection = selectedIds.length > 0;
  const hasGroupForSelection = groups.some(g =>
    g.strokeIds.some(id => selectedIds.includes(id)),
  );

  const anyMarquee = selectionRectStart && selectionRectEnd;

  return (
    <section className="bf-panel">
      <h2>Canvas (SVG vector)</h2>
      <p className="bf-helptext">
        Choose a tool: stroke for manual lines, circle for round shapes, letter
        skeleton to drop a constructed base, or selection to draw a rectangle
        that toggles all strokes inside. Click once to set a stroke start; click
        again to finish. In circle mode, the first click is the center, the
        second defines the radius. Letter mode inserts a full skeleton aligned
        to the guidelines and the letter&apos;s own width box. Click on a stroke
        to give it a bend handle, then drag the handle to create curves.
        Shift/Ctrl-click to multi-select. Group merges strokes into a unit;
        selecting one stroke of a group selects the whole group. Undo/Redo steps
        backward and forward.
      </p>

      <div className="bf-glyph-editor__svg-layout">
        {/* Left / top: canvas + tools */}
        <div className="bf-glyph-editor__svg-layout-main">
          <div className="bf-glyph-editor__canvas-wrapper bf-glyph-editor__canvas-wrapper--svg">
            <svg
              ref={svgRef}
              width={CANVAS_WIDTH}
              height={CANVAS_HEIGHT}
              viewBox={`0 0 ${CANVAS_WIDTH} ${CANVAS_HEIGHT}`}
              className="bf-glyph-editor__svg-canvas"
              onMouseDown={handleCanvasMouseDown}
              onClick={handleCanvasClick}
              onMouseMove={handleCanvasMouseMove}
              onMouseUp={handleCanvasMouseUp}
              onMouseLeave={handleCanvasMouseUp}
              style={{ cursor: 'crosshair' }}
            >
              {/* Background */}
              <rect
                x={0}
                y={0}
                width={CANVAS_WIDTH}
                height={CANVAS_HEIGHT}
                fill="#ffffff"
              />

              {/* Guidelines (horizontal) */}
              <g
                stroke="#ff5555"
                strokeWidth={1}
                strokeDasharray="6 4"
              >
                <line
                  x1={marginX}
                  y1={baselineY}
                  x2={CANVAS_WIDTH - marginX}
                  y2={baselineY}
                />
                <line
                  x1={marginX}
                  y1={xHeightY}
                  x2={CANVAS_WIDTH - marginX}
                  y2={xHeightY}
                />
                <line
                  x1={marginX}
                  y1={ascenderY}
                  x2={CANVAS_WIDTH - marginX}
                  y2={ascenderY}
                />
                <line
                  x1={marginX}
                  y1={descenderY}
                  x2={CANVAS_WIDTH - marginX}
                  y2={descenderY}
                />
              </g>

              {/* Fictive body / side bearings for this letter */}
              <g
                stroke="#55aaff"
                strokeWidth={1}
                strokeDasharray="4 3"
              >
                <line
                  x1={glyphLeftX}
                  y1={ascenderY}
                  x2={glyphLeftX}
                  y2={descenderY}
                />
                <line
                  x1={glyphRightX}
                  y1={ascenderY}
                  x2={glyphRightX}
                  y2={descenderY}
                />
              </g>

              {/* Reference letter (editor only, not exported) */}
              {previewLetter && (
                <text
                  x={(glyphLeftX + glyphRightX) / 2}
                  y={baselineY}
                  textAnchor="middle"
                  fill="#000000"
                  opacity={0.22}
                  style={{
                    fontFamily: 'Arial, sans-serif',
                    fontSize: CANVAS_HEIGHT * 0.7,
                  }}
                >
                  {previewLetter}
                </text>
              )}

              {/* Real strokes */}
              <g
                fill="none"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                {strokes.map(stroke => {
                  const { id, p0, p1, ctrl, width } = stroke;
                  const isSelected = selectedIds.includes(id);

                  const mainStrokeColor = isSelected ? '#0070f3' : 'black';
                  const mainStrokeOpacity = isSelected ? 1 : 0.8;

                  const hasCtrl = !!ctrl;

                  const handleStrokeClickWrapper = (
                    e: React.MouseEvent<
                      SVGPathElement | SVGLineElement,
                      MouseEvent
                    >,
                  ) => handleStrokeClick(e, id);

                  const handleStrokeMouseDownWrapper = (
                    e: React.MouseEvent<
                      SVGPathElement | SVGLineElement,
                      MouseEvent
                    >,
                  ) => handleStrokeMouseDown(e, id);

                  return (
                    <g key={id}>
                      {hasCtrl && ctrl ? (
                        <>
                          {/* Main curved stroke */}
                          <path
                            d={`M ${p0.x} ${p0.y} Q ${ctrl.x} ${ctrl.y} ${p1.x} ${p1.y}`}
                            stroke={mainStrokeColor}
                            strokeWidth={width}
                            opacity={mainStrokeOpacity}
                            style={{ cursor: 'pointer' }}
                            onClick={handleStrokeClickWrapper}
                            onMouseDown={handleStrokeMouseDownWrapper}
                          />

                          {/* Helper lines + handle only when selected */}
                          {isSelected && (
                            <>
                              <g
                                stroke="#0070f3"
                                strokeWidth={1}
                                strokeDasharray="4 4"
                              >
                                <line
                                  x1={p0.x}
                                  y1={p0.y}
                                  x2={ctrl.x}
                                  y2={ctrl.y}
                                />
                                <line
                                  x1={ctrl.x}
                                  y1={ctrl.y}
                                  x2={p1.x}
                                  y2={p1.y}
                                />
                              </g>
                              <circle
                                cx={ctrl.x}
                                cy={ctrl.y}
                                r={6}
                                fill="#0070f3"
                                stroke="#ffffff"
                                strokeWidth={2}
                                style={{ cursor: 'grab' }}
                                onMouseDown={e => startDragControl(e, id)}
                              />
                            </>
                          )}
                        </>
                      ) : (
                        // Straight line (no ctrl yet)
                        <line
                          x1={p0.x}
                          y1={p0.y}
                          x2={p1.x}
                          y2={p1.y}
                          stroke={mainStrokeColor}
                          strokeWidth={width}
                          opacity={mainStrokeOpacity}
                          style={{ cursor: 'pointer' }}
                          onClick={handleStrokeClickWrapper}
                          onMouseDown={handleStrokeMouseDownWrapper}
                        />
                      )}
                    </g>
                  );
                })}

                {/* Preview stroke while drawing */}
                {pendingStart &&
                  previewPoint &&
                  (drawMode === 'stroke' || drawMode === 'circle') && (
                    <line
                      x1={pendingStart.x}
                      y1={pendingStart.y}
                      x2={previewPoint.x}
                      y2={previewPoint.y}
                      strokeWidth={8}
                      stroke="#0070f3"
                      opacity={0.6}
                      strokeDasharray="4 4"
                    />
                  )}
              </g>

              {/* Marquee rectangle */}
              {anyMarquee && selectionRectStart && selectionRectEnd && (
                <rect
                  x={Math.min(selectionRectStart.x, selectionRectEnd.x)}
                  y={Math.min(selectionRectStart.y, selectionRectEnd.y)}
                  width={Math.abs(selectionRectEnd.x - selectionRectStart.x)}
                  height={Math.abs(selectionRectEnd.y - selectionRectStart.y)}
                  fill="rgba(0, 112, 243, 0.1)"
                  stroke="#0070f3"
                  strokeWidth={1}
                  strokeDasharray="4 2"
                />
              )}
            </svg>
          </div>

          {/* Stroke actions */}
          <div className="bf-glyph-editor__actions">
            <label className="bf-glyph-editor__label">
              Tool
              <select
                value={drawMode}
                onChange={e =>
                  setDrawMode(e.target.value as DrawMode)
                }
                className="bf-input bf-input--small"
              >
                <option value="stroke">Stroke (path-like)</option>
                <option value="circle">Circle (approx.)</option>
                <option value="letter">Letter skeleton</option>
                <option value="select">Selection rectangle</option>
              </select>
            </label>

            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={() => adjustWidth(-1)}
              disabled={!hasSelection}
            >
              Thinner
            </button>
            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={() => adjustWidth(+1)}
              disabled={!hasSelection}
            >
              Thicker
            </button>
            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={handleGroupSelection}
              disabled={selectedIds.length < 2}
            >
              Group
            </button>
            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={handleUngroupSelection}
              disabled={!hasGroupForSelection}
            >
              Ungroup
            </button>
            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={handleUndo}
              disabled={history.length === 0}
            >
              Undo
            </button>
            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={handleRedo}
              disabled={redoStack.length === 0}
            >
              Redo
            </button>
            <button
              type="button"
              className="bf-button bf-button--secondary"
              onClick={handleDeleteSelected}
              disabled={!hasSelection}
            >
              Delete selected
            </button>
            <button
              type="button"
              className="bf-button bf-button--ghost"
              onClick={handleClearAll}
              disabled={strokes.length === 0}
            >
              Clear all
            </button>
          </div>

          {/* Upload button (SVG via useGlyphs hook) */}
          <div className="bf-glyph-editor__actions">
            <button
              type="button"
              className="bf-button bf-button--primary"
              onClick={handleUploadToBackend}
              disabled={
                !strokes.length ||
                !letter.trim() ||
                !sid ||
                isUploadingGlyph
              }
            >
              {isUploadingGlyph ? 'Saving...' : 'Save glyph to backend'}
            </button>
          </div>
        </div>

        {/* Right / bottom: SVG code */}
        <div className="bf-glyph-editor__svg-layout-code">
          <h3>SVG code</h3>
          <p className="bf-helptext">
            This is the SVG that corresponds to the current glyph. It contains
            only the real strokes (lines or curves), no guidelines, no reference
            letter, but the geometry now respects the per-letter width box that
            will later be used in the font.
          </p>
          <pre className="bf-glyph-editor__code">
            <code>{svgCode}</code>
          </pre>
        </div>
      </div>
    </section>
  );
};

export default SvgGlyphEditor;
